php artisan serve

composer create-project laravel/laravel name устаноука ларавель

Команда composer dump-autoload используется, 
когда нужно обновить загрузчик, поскольку появились новые классы.

composer require laravel/ui - установка bootstrap
php artisan ui bootstrap подключение bootstrap

composer clear-cache

Команда php artisan migrate запускает 
миграцию данных из файлов миграции базы данных в базу данных.

DB_CONNECTION=mysql начто надо поменять

 php artisan migrate:fresh команда, обновляет таблицы


php artisan make:controller WorkerController Создаем контроллер

php artisan make:model Worker Создаем модел

php artisan make:migration create_workers_table создаем таблицу

php artisan migrate:rollback откатываем таблицу/удаляем

php artisan make:model Picture -m создает связанные 
модель и миграцию (Picture это имя с большй буквы) (расположение app-->modules  и databases ==>migration)

alt + J выбираем все одинаковые слова
alt + insert создать конструкто и не только

composer self-update обновление компосера
_______________________________________________________
PHP_EOL перенос строки
floatval();
intval();
define(name,значение) константа, ее нельзя поменять.
_---------------------------------------------------------
protected;
private;
public; <------ Это три модификатора уровня доступа;

echo '<pre/>' преформатирование текста

*Ctrl + Alt + L — форматирование кода в соответствии с настройками code style.

declare(strict_types=1) — это выражение, обеспечивающее строгую типизацию в приложениях PHP.
---------------------------------------------------------------------------------------
$this - это указатель на обьект текущего класса.
this - означает, что мы обращаемся к будущему объекту, который будет создан на основе этого класса.
--------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------
CВОЙСТВА: public string $name и.т.п. Свойства относятся к фиксированным значениям.
МЕТОДЫ: public function name();
-------------------------------------------------------------------------------------


php -S localhost:4000 запуск сервера    
http://localhost:4000 адрес сервера(скопировать)
php  -i | find /i "Configuration file" вроде находит путь к php.ini;

https://www.youtube.com/watch?v=PpvlkTQoX5E установка в open server Laravel c 7 мин;


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
https-название протокола;
:// - разделение;
www.youtube.com - доменное имя сайта;
:8080 - номер порта по которому будет идти подключение;
после вопросительного знака идет Get параметр,
 параметр самого запроса ?v=PpvlkTQoX5E;
подключение к сайту осуществляется не по доменному имени а по айпи;
localhost это доменное имя, которому сопаставлен айпиАдрес 127.0.0.1;
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

 $_GET — это суперглобальный массив, который используется для извлечения данных, отправленных на сервер с использованием методов GET в HTTP-запросе.

break  - оператор служит, чтобы прекратить выполнение цикла

continue - оператор служит, чтобы перейти принудительно на следующую итерацию

include __DIR__ . '/CalculatorSwitch.php';-
include связывает файлы, но лучше использовать require;
require;

________________________________________________________
autoload file:
{
"autoload": {
  "psr-4": {
    "App\\":"app/"
  }
}

}
далее в терминале команда composer install

------------------------------------------------------------------------
 public function __construct(int $id, string $title, string $description)
    {
        $this->id=$id;
        $this->title=$title;
        $this->description=$description;
    }
в этой функции проводится первичная инициализация свойств
------------------------------------------------------------------------

Инкапсуляция - это Протектед, Приват, Паблик
___________________________________

Полиморфизм - это возможноть каждого обЪекта из определенного семейства
 определить свое собственное поведение через теже методы что и в базовом классе(в случае наследования)
___________________________________

abstract - абстрактный класс, на осонове которого не будут создаваться объекты, но можно наследоваться другими классами
-------------------------------------------------

class Book extends Product
{
    public function getDescription()
    {
        return parent::getDescription() . '. это книга';
    }
} Ключевое слово parent ссылается на родителя(на свойство гетДескрипшн, которе прописано у Продукт родителя.
parent это в контексте объекта. Есть еще ключквые слова self и static - это контекст Класса.
Static метод создается, если нужно использовать метод класса или свойство, не создавая объекта класса(вызвать метод из класса)
Self используется вместо this, только this для объекта, а self для свойства статического:
self::$name
_____________________________________________________________________

Отличие Абстрактного класса abstract от Интерфейса Interface, в том что в абстрактном клаассе можно задать базовую реализацию этого метода, а Интерфейс может только объявить метод без реализации;
______________________________________________________________________

unset() — это встроенная функция PHP, которая уничтожает указанные переменные или элементы массива.

Синтаксис функции: `unset($variable)`.











































-------------------------------------------------------------------------
<?php

if (!function_exists('dump')) {
    function dump($var,  $label = ''){
        echo $label . '<br>';						   ФУНКЦИЯ DUMP
        echo '<pre>';
        echo var_export($var, true) . '<br>';
        echo '</hr>';
    }
}
________________________________________________________________________

MAGIC METHODS
перегрузка свойств и методов относится к магик методс;
Магич Методы - так называются, потому что они заранее предопределены ивызываются внутренними механизмами PHP,
То есть вы сами напрямую их вызывать не будете;\
__FUNCTION__ возвращает только имя функции, тогда как __METHOD__ возвращает имя класса вместе с именем функции

магический метод __get вызывается при обращении к несуществующему свойству;
метод __isset принимает на вход название свойства, которое проверяется на существование.То есть если мы проверяем на вход не существующее свойство, то вызывается этот метод Иссет.
метод __set вызовится, если мы попытаемся присвоить или изменить значение не существующему свойству;
магич метод __construt вызывается при созданиее объекта автоматически($name = new magicMethod());
метод __destruct() - вызывается при уничтожении класса;
метод __callStatic - статический метод который вызывается, когда мы пытаемся вызвать метод статический,
которого не существует внутри класса.

unset() — это встроенная функция PHP, которая уничтожает указанные переменные или элементы массива.
Синтаксис функции: `unset($variable)`.

В PHP ключевое слово static используется для объявления членов класса (свойств и методов), которые принадлежат самому классу, а не экземплярам класса (объектам).
Статические члены являются общими для всех экземпляров класса, и к ним можно получить доступ без создания объекта класса.
----------------------------------------------------------------------------------------------------------------
Абстрактные классы в PHP — это классы, предназначенные для наследования от них. При этом объекты таких классов нельзя создать.

Для того, чтобы объявить класс абстрактным, нужно при его объявлении написать ключевое слово abstract.

Абстрактные классы также могут содержать абстрактные методы. Такие методы не должны иметь реализации, а нужны для того, чтобы указать, что такие методы должны быть у потомков. Реализация таких методов — уже задача потомков.

При наследовании от абстрактного класса все методы, помеченные абстрактными в родительском классе, должны быть определены в дочернем классе.
----------------------------------------------------------------------------------------------------------------------
var_dump — Выводит информацию о переменной
-------------------------------------------------------------------------------------


Согласно источнику, для решения ошибки «Illuminate database queryexception» в Laravel можно включить расширение php_pdo_mysql.dll в файл php.ini. Для этого нужно выполнить следующие шаги:

Обновить файл php.ini в папке PHP. Для этого нужно открыть файл php.ini в папке PHP и добавить следующую строку: extension=php_pdo_mysql.dll.

Обновить файл php.ini в папке XAMPP. Для этого нужно открыть файл и добавить следующее расширение: extension=php_pdo_mysql.dll.

Перезапустить XAMPP. Для этого нужно открыть панель управления и перезапустить Apache и MySQL.

После выполнения этих шагов можно будет повторно запустить команду PHP artisan migrate.
---------------------------------
Соблюдаем сигнатуру методов
---------------------------------------------

Сеттеры и Геттеры:

Сеттер - это метод который обычно получают какойто аргумент и меняют свойство ,которое мы указали у класса.

$name = Vasya;
public function setName($name){
$this->name=$name;
}
$obj = newClass(); объект на основе какого то класса;
$obj->setName(Bob);
echo $obj->$name;










----------------------------------------------------------------------------------------------------
<?php
$number = 11;
$var = 2;
// $number += $var; $number = $number + $var;
// $number *= $var; $number = $number * $var;
// $number -= $var; $number = $number - $var;
// $number /= $var; $number = $number / $var;
// $number %= $var; $number = $number % $var;
// $number **= $var; $number = $number ** $var;
// $number .= $var; $number = $number . $var;

//echo $number ** $var;
//echo 11 ** 0.5;

// инкремент ++ декримент --
// echo $var . "<br>";
// //++$var; префиксный
// $var++;   //постфиксный 
// echo $var . "<br>";


$var1 = 1;
$var2 = 11;
// Префиксная форма
//echo ++$var1 . "<br>";

// постфиксная форма
echo $var2++ . "<br>";
echo $var2 . "<br>";

// $abc = "bbb";
// echo ++$abc; //1bbb bbb1


?>
---------------------------------------------------------------------------------------------
<?php
$alpha = 'c';
if ($alpha == 'b'): 
	?>
<h1>Обычный HTML h1</h1>
<?php
elseif ($alpha == 'a'): 
	?>
<h2>Обычный HTML h2</h2>
<?php
else: ?>
<h3>Обычный HTML h3</h3>
<?php
endif;
?>
---------------------------------------------------------------------------------------------
// Условный оператор
ТЕРНАРНЫЙ ОПЕРАТОР
// x ? y : z
// выражение1 ? выражение2 : выражение3 

$x = -13;
$x = $x > 0 ? $x = 11 : $x; // тернарный оператор
echo $x;
?>
--------------------------------------------------------------------------------------------------
// Переключатель switch

// $someText = 'okey';
// switch ($someText) {
// 	case 'value':
// 		echo 'Выражение равно okey-2';
// 		break;

// 	case 'okey':
// 		echo 'Выражение равно okey';
// 		break;
	
// 	default:
// 		echo 'Выражение не равно okey';
// 		break;
// }
-----------------------------------------------------------------------------
// $num = 100;

// switch (true) {
// 	case ($num > 0 && $num <= 50):
// 		echo "true";
// 		break;
	
// 	case ($num > 0 && $num <= 500):
// 		echo "true-2";
// 		break;

// 	default:
// 		echo "false";
// 		break;
// }


// Оператор goto

$nums = 1;

bg:
$nums++;
echo "$nums<br>";
if ($nums >= 22) goto fsh;
goto bg;
fsh:
-------------------------------------------------------------------------------------------------------------------
Цикл while

// while (условие){ // true, false
// 	#операторы;
// }

$i = 10;
// while ($i <= 200) {
// 	echo "$i <br>";
// 	$i++;
// }

// while (true) {
// 	$i++;
// 	// здесь будет условие выхода из цикла
// 	if ($i > 20) break;
// 	echo "$i <br>";
// }

// while (--$i) {   // 10, 9, 6 ит.д. = true 0 = false
// 	echo "$i <br>";
// }

while ($i--) {   // 10, 9, 6 ит.д. = true 0 = false
	echo "$i <br>";
}
=================================================================================================================================
 Массивы
// Ассоциативные и индексные массивы

$arr = ['name' => 'Andrei', 'age' => 31];
$arr2 = ['Andrei', 31];

// echo "<pre>";
// print_r($arr);
// echo "</pre>";

// echo "<pre>";
// print_r($arr2);
// echo "</pre>";

// echo $arr['age'];

// многомерные массивы

$people = [
	'Ivan' => ['age' => 21, 'weight' => 63],
	'Oleg' => ['age' => 25, 'weight' => 70],
	'Nika' => ['age' => 19, 'weight' => 53]
];

echo $people['Oleg']['weight'] . "<br>";

// интерполяция элемента массива в строку
$arr3['time'] = 10;
echo "Сейчас у нас $arr3[time] утра"."<br>";

echo "Олег имеет вес в {$people['Oleg']['weight']} кг.";

// Массивы
$arr = [1, 2, 3];

list($one, $two, $three) = $arr;

echo $two . "<br>";
echo $arr[1];
echo $three . "<hr>";

// Обход массива
for ($i=0; $i < count($arr); $i++) { 
	echo $arr[$i] . "<br>";
}

$andrei = [
	'name' => 'Andrei',
	'age' => 31,
	'weight' => 73
];

// foreach ($andrei as $key => $value) {
// 	echo $key . "-" . $value . "<br>";
// }

// foreach ($andrei as $val) {
// 	echo $val . "<br>";
// }

foreach ($arr as $value) {
	echo $value . "<br>";
}


<?php
-------------------------------------------------------------------------------------------------------------
// параметры функций
// function getResult($var) {
// 	$var = $var * 2;
// 	return $var;
// }

// $new = 10;
// echo getResult($new) . "<br>";
// echo $new . "<hr>";


// function getResult(&$var) {
// 	$var = $var + 2;
// 	return $var;
// }

// $new1 = 10;
// echo getResult($new1) . "<br>";
// echo $new1;

// Необязательные параметры
function getResult($var1 = 2, $var2 = 4) {
	$var = $var1 * $var2;
	return $var;
}

// echo getResult() . "<br>";
// echo getResult(3) . "<br>";
// echo getResult(5, 5);

// переменное (или изменяемое) количество параметров

function mylist(...$items){
	foreach ($items as $v) {
		echo $v . "<br>";
	}
}

//mylist('Nick', 'Mike', 'Sara', 'Andrei');

$some =['PHP', 'Python', 'JS', 'HTML', 'CSS'];
mylist(...$some);
?>
-------------------------------------------------------------------------------------------------------------
// Глобальные переменные

function getSum(){
	global $var;
	$var = 2;    	// локальная переменная
	return $var;
}

$var = 5;			// внешняя переменная

echo getSum() . "<br>";
echo $var . "<hr>";

// статические переменные

function calculator(){
	static $start = 0;
	return ++$start;
}

echo calculator();
echo calculator();
echo calculator();
echo calculator() . "<hr>";

// Возврат функцией массива

function myFriends(){
	$kate = 'Kate';
	$nick = 'Nick';
	$vadim = 'Vadim';

	return [$kate, $nick, $vadim];
}
echo "<pre>";
print_r(myFriends());
echo "</pre>";

?>
------------------------------------------------------------------------------------------------
Рекурсивные функции
Рекурсивные функции — это функции, которые вызывают сами себя.

В отличие от цикла, рекурсивные функции не просто повторяются несколько раз, а работают «внутри» друг друга.


function recur($num){
	// Если параметр $num меньше 10, продолжаем рекурсию
	if ($num > 10) {
		// Уменьшать значение параметра $num и его выводим в браузер
		echo ($num--) . '<br>';
		// Производим рекурсивный вызов функции
		recur($num);
	}else return;
}

// recur(15);

// Факториал - произведение всех целых чисел, меньших или равных данному числу. n! = 1*2*3*4*5*......
function factorial($num){
	if ($num <= 1) return 1;
	// здесь у нас происходит повторный вызов функции
	return $num * factorial($num - 1);
}
// echo factorial(11);

function factorial2($num){
	$result = 1;
	for ($i=1; $i <= $num; $i++) { 
		$result *= $i;
	}
	return $result;
}

echo factorial2(11);

?>
----------------------------------------------------------------------------------------------------
<?php
// Вложенные функции
$arr = [1, 2, 4];

function box(){

	function inn(){
		echo "TEST";
	}
	inn();
	print_r($arr);
}
// print_r()

// Динамическое имя функции функция с именем

function hello(){
	// return 'Hello';
	echo 'hello';
}
// $var = hello();

// Анонимные функции
В анонимной функции ставятся точка зяпятой вконце функции....
В версиях PHP 5.6 и выше список аргументов может содержать многоточие ...чтобы показать,
 что функция принимает переменное количество аргументов.

иными словами вызвав функцию например так:
debug(1, 2, 3);

внутри функции эти параметры будут доступны как элементы массива $params
$some = function (...$arr1){
	foreach($arr1 as $vel){
		echo $vel . '<br>';
	}
};
// $some(12, 34, 53, 3465, 343);

$var2 = function (){
	echo 'Запуск анонимной функции';
};
$var2();


?>
--------------------------------------------------------------------------------------------------------------
<?php
Замыкание - это функция, которая запоминает состояние окружения в момент своего создания. 
echo "<h2> Замыкания</h2>";

$mess = 'текст до момента создания функции <br>';

$test = function (array $some) use ($mess){
	if (isset($some) && count($some) > 0) {
		echo $mess;
		foreach($some as $li){
			echo $li . '<br>';
		}
	}
};

$test([]);
$some[] = 'типа текст';
$test($some);
// изменение окружения
$mess = 'изменненный текст <br>';
$mess = false;

$some = [12, 32, 43, 53];
$test($some);


?>
----------------------------------------------------------------------------------------------------------------
// количество символов в строке
$str = '   hello   -   people   
12';
echo strlen($str) . '<br>';

// Поиск внутри строки
echo substr($str, 1, 2) . '<br>';

echo strpos($str, 'p') . '<br>';

$text = "PHP - довольно простой - язык - программирования";

echo substr($text, strpos($text, 'доволь')) . '<br>';


// замена текста внутри строки
$textNew = str_replace("-", "=", $text);
echo $textNew . '<br>';

// удаление пробелов и переносов
 echo trim($str);
=======================================================================================================
                   Функции из строки в массив и наоборот:
<?php
$str = 'Имя, Фамилия, email, mobile';

$newArr = explode(',', $str);

echo "<pre>";
print_r($newArr);
echo "</pre>";

$newStr = implode(';', $newArr);
echo $newStr;

// Сериализация объектов и массивов
// serialize(value)
// unserialize(str)

$num = [11, 2323, 423, 534, 54];

$str = serialize($num);
echo $str . "<br>";

$arr = unserialize($str);
echo "<pre>";
print_r($arr);
echo "</pre>";
?>
===========================================================================================================
JSON (JavaScript Object Notation) — это текстовый формат обмена данными, основанный на JavaScript. Он представляет собой набор пар {ключ: значение}. Значение может быть массивом, числом, строкой и булевым значением.

В PHP поддержка JSON появилась с версии 5.2.0 и работает только с кодировкой UTF-8.

Для кодирования массива или объекта в JSON используется функция json_encode($value, $options).

Для декодирования строки в объект используется функция json_decode($json).

echo '<h1>JSОN-формат</h1>';

$arr = [
  'fio' => 'Иванов Степан', 
  'age' => '33', 
  'vk_url' => 'https://vk.com/id11111',
  'learn' => ['HTML', 'CSS', 'PHP']
];

echo json_encode($arr, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES) . "<br>";
//json_decode(json);
$json = '{"people":"Сидоров Никита","adress":"Ленина 23б","mob":["0936326456","0977546412"]}';

$arr2 = json_decode($json, true);

echo '<pre>';
print_r($arr2);
echo '</pre>';
?>
--------------------------------------------------------------------------------------------------------------
Функция empty(). Она проверяет, является ли массив пустым, и возвращает логическое значение.
--------------------------------------------------------------------------------------------------------------
Различия между методами POST и GET в протоколе HTTP:

Цель использования. GET применяется для запроса данных с сервера, а POST — для отправки данных на сервер для обработки. 1
Передача данных: 1
GET: параметры передаются в URL. Ограничение по размеру запроса зависит от браузера и сервера. Данные видны в URL, что делает их менее безопасными. 1
POST: информация передаётся в теле запроса. POST-запросы могут передавать большие объёмы данных без ограничений. 
Данные не видны в URL, что делает их более безопасными для передачи чувствительной информации. 
=====================================================================================================================
Htmlspecialchars() в PHP — это функция, которая преобразует специальные символы в HTML-сущности. 12

В HTML некоторые символы имеют особый смысл и для сохранения своего значения должны быть преобразованы.
 Функция возвращает строку, над которой проведены эти преобразования.
===============================================================================================================
move_uploaded_file — Перемещает загруженный файл в новое место

Описание ¶
move_uploaded_file(string $from, string $to): bool
Эта функция проверяет, является ли файл from загруженным на сервер (переданным по протоколу HTTP POST). Если файл действительно загружен на сервер, он будет перемещён в место, указанное в аргументе to.

Такая проверка особенно важна в том случае, если существует шанс того, что какие-либо действия, производимые над загруженным файлом, могут открыть его содержимое пользователю или даже другим пользователям системы.
---------------------------------------------------------------------------------------------------------------
$_FILES в PHP — это глобальная переменная, представляющая собой ассоциативный массив, в котором находится информация о загруженном файле с помощью метода HTTP POST. 1

Для каждого загруженного файла массив содержит следующие данные: 3

$_FILES['userfile']['name'] — исходное имя файла, такое, каким его видел пользователь, выбирая файл; 3
$_FILES['userfile']['type'] — mime/type файла, к примеру, может быть image/gif; 3
-------------------------------------------------------------------------------------------------------------
Описание
enctype Определяет способ кодирования данных формы при их отправке на сервер. Обычно устанавливать значение атрибута enctype не требуется, данные вполне правильно понимаются на стороне сервера. Однако если используется поле для отправки файла (input type="file"), следует определить атрибут enctype как multipart/form-data.

Синтаксис
<form enctype="application/x-www-form-urlencoded | multipart/form-data | text/plain">
...
</form>
------------------------------------------------------------------------------------------


https://www.w3schools.com/mysql/default.asp сайт с sql коммандами

https://yandex.ru/video/preview/14626356757038014096 решаем проблему с Target class [MyPlaceController] does not exist

https://stackoverflow.com/questions/42570065/laravel-5-4-specified-key-was-too-long-error ссылка решение проблема с миграциями(решение в файле AppServiceProvider, находится в app)
что нужно скопировать:
// AppServiceProvider

use Illuminate\Support\Facades\Schema;

public function boot()
{
    Schema::defaultStringLength(191);
}
--------------------------------------------------------------------------------------------------
комбинации клавишь:
alt+j выбрать несколько слов
ctrl+w выделить всё слово
html: 5 команда чтобы создать скелет html

--------------------------------------------------------------------------------------------------
то что нужно обычно прописывать в классе в Models:

use Illuminate\Database\Eloquent\SoftDeletes;
class Post extends Model
{
    use SoftDeletes; (use Illuminate\Database\Eloquent\SoftDeletes;) это сверху, означает use SoftDeletes в моделях Laravel позволяет реализовать мягкое удаление записей. Это мощный инструмент для работы с данными, который помогает сохранять информацию и восстанавливать её при необходимости
    use HasFactory;
    protected $table = 'posts';
    protected $guarded = [];
}

и эту строчку в Миграции:
$table->softDeletes();

----------------------------------------------------------------------------------------------------
пример роута route:
Route::get('/post',[\App\Http\Controllers\PostController::class,'post']);
Route::get('/picture',[\App\Http\Controllers\PictureController::class,'picture']);
-------------------------------------------------------------------------------------------
методы поиска в контроллерах:

class PostController extends Controller
{
1111   function index(){
        $post = Post::find(1);
        dd($post);
    }
}
222   function index(){
        $posts = Post::all();
        foreach ($posts as $post) {
            dump($post->title);
        }
        dd('end');
    }

3333  function index(){
        $posts = Post::where('is_published',1)->get();
        foreach ($posts as $post) {
            dump($post->likes);
        }
    }

----------------------------------------------------------------

    <!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Bootstrap demo</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
</body>
</html>
скелет на бутстрап bootstrap
-----------------------------------------------------------------------------------------------------------------------------------------

очистка кеша php artisan config:cache
объект $request это объект который представляет из себя те данные, которые мы получаем от пользователя из формы
php artisan config:cache -команда для очистки кеша после изменения в вайле env.
----------------------------------------------------------------------------------------------------------------------------------------------
https://www.w3schools.com/sql/ сайт с примерами запросов
SQL комманды:
SELECT * FROM name1313.new_table1313 where `like` = 111;
UPDATE `name1313`.`new_table1313` SET `title` = 'dogs' WHERE (`id` = '2');
DELETE FROM `name1313`.`new_table1313` WHERE (`id` = '1');
таблица связывающая таблицы называется пивот
--------------------------------
traite трейт - это метод реализации какойто логики
------------------------------------
SELECT test13.categories.title,
test13.posts.title 

from test13.posts

inner join test13.category_post
on test13.posts.id = test13.category_post.post_id

inner join test13.categories
on test13.categories.id = test13.category_post.category_id;
---------------------------------------------------------------
DB_CONNECTION=mysql
 DB_HOST=127.0.0.1
 DB_PORT=3306
 DB_DATABASE=bigtasty
 DB_USERNAME=root
 DB_PASSWORD=
__________________________________________________________________
crud - create reade update delete

                                                 CREAT:
  public function create() {
        Post::create([
            'title' => 'title post',
            'content' => 'content some',
            'image' => 'images.jpg',
            'likes' => 55,
            'is_published' => '1',
        ]);
        dd('created');
    }

                                                   READ наиболее часто используемые методы чтобы вытянуть данные(read) примеры:
1)first
class PostController extends Controller
{
   public function index(){
        $post = Post::where('is_published', 0)->first();

            dump($post->title);

        dd('end');
    }
}

2)get
class PostController extends Controller
{
    public function index()
    {
        $posts = Post::where('is_published', 1)->get();
        foreach ($posts as $post) {
            dump($post->title);
        }
        dd('end');
    }
}

3)all
class PostController extends Controller
{
    public function index()
    {
        $posts = Post::all();
        foreach ($posts as $post) {
            dump($post->title);
        }
        dd('end');
    }
}

                                                        UPDATE
  public function update()
    {

        $post = Post::find(10);
        $post->update([
            'title' => ' update',
            'content' => 'update',
            'image' => 'update',
            'likes' => 533,
            'is_published' => '0',
        ]);
        dd('updated');
    }

                                                         DELETE
   public function delete() {
        $post = Post::find(5);           удаляем
        $post->delete();
        dd('del');
    }

                                                         FIRST OR CREATE: 
public function firstOrCreate() {
    $arrPosts = [
        ['title' => 'Первый пост', 'content' => 'Содержание первого поста', 'image' => 'asd.jpg', 'likes' => 11, 'is_published' => 1],
        ['title' => 'второй пост', 'content' => 'Содержание второго поста', 'image' => 'asd2.jpg', 'likes' => 22, 'is_published' => 1],
        ['title' => '3333 пост', 'content' => 'Содержание второго поста', 'image' => 'asd2.jpg', 'likes' => 22, 'is_published' => 1],
    ];

    $post = Post::firstOrCreate(
        [ 'title' => 'Первый пост'],  //если есть тайтл с таким содержанием, то выводит его, если его нету ,то создаёт его
        ['title' => 'some post', 'content' => 'Содержание some content', 'image' => 'as333d.jpg', 'likes' => 133, 'is_published' => 1]
    );
    dump($post ->content);
    dd('finished');
    }
							UPDATE OR CREATE:  тоже что и create только update
   public function updateOrCreate() {
    $arrPosts = [
        ['title' => 'Первый пост', 'content' => 'Содержание первого поста', 'image' => 'asd.jpg', 'likes' => 11, 'is_published' => 1],
        ['title' => 'второй пост', 'content' => 'Содержание второго поста', 'image' => 'asd2.jpg', 'likes' => 22, 'is_published' => 1],
        ['title' => '3333 пост', 'content' => 'Содержание второго поста', 'image' => 'asd2.jpg', 'likes' => 22, 'is_published' => 1],
    ];

    $post = Post::updateOrCreate(
        [ 'title' => 'Первый пост'],
        ['title' => ' update some post', 'content' => 'Содержание some content', 'image' => 'as333d.jpg', 'likes' => 133, 'is_published' => 1]
    );
    dump($post ->content);
    dd('finished update');
    }
--------------------------------------------------------------------------------------------------
1. PK (Primary Key)
Первичный ключ.

Уникально идентифицирует каждую запись в таблице.

Не может содержать NULL значения.

В таблице может быть только один первичный ключ.

2. NN (Not Null)
Не может быть NULL.

Столбец обязательно должен содержать значение.

Если попытаться вставить NULL в такой столбец, возникнет ошибка.

3. UQ (Unique)
Уникальное значение.

Все значения в этом столбце должны быть уникальными.

Например, это полезно для столбцов с email или username.

4. B (Binary)
Бинарный столбец.

Используется для хранения бинарных данных (например, изображений, файлов).

Обычно применяется для типов данных BINARY или VARBINARY.

5. UN (Unsigned)
Беззнаковое число.

Применяется для числовых типов данных (например, INT, FLOAT).

Означает, что столбец может хранить только положительные числа или ноль.

6. ZF (Zero-Filled)
Заполнение нулями.

Применяется для числовых типов данных.

Если указана длина числа (например, INT(5)), то число будет дополнено нулями слева до указанной длины.

Например, число 42 станет 00042.

7. AI (Auto Increment)
Автоинкремент.

Автоматически увеличивает значение столбца при добавлении новой записи.

Обычно используется для первичных ключей.

Например, если последнее значение было 5, следующее будет 6.

8. G (Generated Column)
Генерируемый столбец.

Значение столбца вычисляется на основе других столбцов таблицы.

Может быть VIRTUAL (вычисляется на лету) или STORED (значение сохраняется в таблице).

----------------------------------------------------------------------------------------------------------------------------
миграции добавление разных:
                                                                                    ADD column
  public function up(): void 
    {
        Schema::table('posts', function (Blueprint $table) {
            $table->text('description')->nullable()->after('content');

        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('posts', function (Blueprint $table) {
            $table->dropColumn('description');
        });
    }

										delete column
    public function up(): void
    {
        Schema::table('posts', function (Blueprint $table) {
            $table->dropColumn('description');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('posts', function (Blueprint $table) {
            $table->text('description')->nullable()->after('content');
        });
    }
										rename column
   public function up(): void
    {
        Schema::table('posts', function (Blueprint $table) {
            $table->renameColumn('content', 'post_content');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('posts', function (Blueprint $table) {
            $table->renameColumn('post_content', 'content');
        });
    }

										chanche type
   public function up(): void
    {
        Schema::table('posts', function (Blueprint $table) {
            $table->string('post_content')->change();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('posts', function (Blueprint $table) {
            $table->text('post_content')->change();
        });
    }
										delete table
public function up(): void
    {
        Schema::dropIfExists('posts');
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::create('posts', function (Blueprint $table) {
            $table->id();
            $table->string('title');
            $table->string('post_content');
            $table->string('image')->nullable();
            $table->unsignedBigInteger('likes')->nullable();
            $table->boolean('is_published')->default(1);
            $table->timestamps();

            $table->softDeletes();
        });
    }
-------------------------------------------------------------------------------------------------------------------------------------------

1) index() => этот метод предоставляет вам все данные из базы данных.

2) create() => это метод для создания новой записи.

3) store() => этот метод хранит данные в вашей базе данных.

3) show() => этот метод показывает запись.

3) edit() => используя этот метод, мы можем отредактировать нашу запись.

3) update() => это метод для обновления записи.

7) destroy() => используя этот метод, мы можем удалить нашу запись.
---------------------------------------------------------------------------------------------------------------------------------------------
команды на GIT
git --version версия гита;
git init  создаем пустой репозиторий гита;
git status показывает список файлок, которые гитом еще не доавлены;
git add * гит добавляет все файлы;
git commit -m "комментарий"  Команда git commit -m "comment" создает новый коммит (фиксацию изменений) в Git, сохраняя текущее состояние файлов в истории репозитория.
git push -u github13(имя) master(имя ветки);
git brunch какие ветки;
git fetch вытягивает ветки из гитхаба в php;
git branch -r;
git checkout name - переключение между ветками;

ОСНОВНЫЕ КОМАНДЫ:
1.git clone - закачать себе проект
2. git add - добавить изменения
3. git commit - зафиксировать изменения
4. git push - отправить изменения
5. git pull - скачать проект с изменениями
6. merge - смержить, объединить изменения одного файла из двух источников
7. git branch - создать аналог на основе исходного проекта
8. git checkout переключить отображение варианта проекта
------------------------------------------------------------------------------
 git checkout -b developp(имя) github13/developp ; (git checkout -b developp

Создаёт новую локальную ветку с именем developp
И сразу переключает на неё
github13/developp
Это ссылка на удалённую ветку (remote branch)
Формат: <имя-удалённого-репозитория>/<имя-ветки>
В данном случае:
github13 - имя удалённого репозитория (как он записан в вашем локальном git)
developp - имя ветки на этом удалённом репозитории
Полный смысл команды:
"Создать новую локальную ветку developp, которая будет отслеживать (track) удалённую ветку developp из репозитория github13, и сразу переключиться на неё")
-----------------------------------------------------------------------------------
2. Добавление нового удалённого репозитория:
git remote add <имя> <url>
Пример:
git remote add upstream https://github.com/other/repo.git
----------------------------------------------------------------------------------------
Команда git push -u origin main выполняет следующие действия:

git push - отправляет ваши локальные изменения в удалённый репозиторий.

-u (или --set-upstream) - связывает текущую локальную ветку с удалённой, чтобы в будущем можно было использовать просто git push без указания параметров.

origin - имя удалённого репозитория (обычно это стандартное имя для репозитория, с которого вы клонировали проект).

main - имя ветки, в которую отправляются изменения (вместо main раньше часто использовалось master, но сейчас main стало стандартом по умолчанию в новых репозиториях).
--------------------------------------------------------------------------------------------------------------------------------------------------------------

